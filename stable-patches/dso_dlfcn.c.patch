diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c
index b5a7b7b..22ef1c8 100644
--- a/crypto/dso/dso_dlfcn.c
+++ b/crypto/dso/dso_dlfcn.c
@@ -19,6 +19,11 @@
 #include "dso_local.h"
 #include "internal/e_os.h"
 
+#ifdef OPENSSL_SYS_ZOS
+# include <zos-base.h>
+# include <zos-io.h>
+#endif
+
 #ifdef DSO_DLFCN
 
 # ifdef HAVE_DLFCN_H
@@ -30,7 +35,7 @@
 #  if defined(__SCO_VERSION__) || defined(_SCO_ELF) || \
      (defined(__osf__) && !defined(RTLD_NEXT))     || \
      (defined(__OpenBSD__) && !defined(RTLD_SELF)) || \
-     defined(__ANDROID__) || defined(__TANDEM)
+     defined(__ANDROID__) || defined(__TANDEM) || defined(OPENSSL_SYS_ZOS)
 #   undef HAVE_DLINFO
 #  endif
 # endif
@@ -400,7 +405,59 @@ static int dladdr(void *ptr, Dl_info *dl)
 
 static int dlfcn_pathbyaddr(void *addr, char *path, int sz)
 {
-# ifdef HAVE_DLINFO
+# ifdef OPENSSL_SYS_ZOS
+    void *dlcb = NULL;
+    char buffer[1024];
+    char filename[1024];
+    char *libpath = getenv("LIBPATH");
+    int len;
+
+    if (addr == NULL) {
+        union {
+            int (*f) (void *, char *, int);
+            void *p;
+        } t = {
+            dlfcn_pathbyaddr
+        };
+        addr = t.p;
+    }
+
+    void *best_dlcb = NULL;
+    unsigned long best_entry_addr = 0;
+    unsigned long target_addr = (unsigned long)addr;
+
+    while ((dlcb = __dlcb_next(dlcb)) != NULL) {
+        /*
+         * Heuristic: 64-bit symbols are allocated in the same memory object
+         * as their DLCB (CELQCB), and the DLCB is at a lower address than
+         * the symbols it represents.
+         */
+        unsigned long entry_addr = (unsigned long)dlcb;
+        if (target_addr >= entry_addr && entry_addr >= best_entry_addr) {
+            best_entry_addr = entry_addr;
+            best_dlcb = dlcb;
+        }
+    }
+
+    if (best_dlcb != NULL) {
+        len = __dlcb_entry_name(buffer, sizeof(buffer), best_dlcb);
+        if (len > 0) {
+            const char *final_path = buffer;
+            if (buffer[0] != '/' && libpath && __find_file_in_path(filename, sizeof(filename), libpath, buffer) > 0) {
+                final_path = filename;
+            }
+            len = (int)strlen(final_path);
+            if (sz <= 0)
+                return len + 1;
+            if (len >= sz)
+                len = sz - 1;
+            memcpy(path, final_path, len);
+            path[len++] = 0;
+            return len;
+        }
+    }
+    return -1;
+# elif defined(HAVE_DLINFO)
     Dl_info dli;
     int len;
 
